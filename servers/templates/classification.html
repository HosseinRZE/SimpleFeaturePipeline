<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OHLCV - LSTM Live Predictions</title>
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
  body { background:#1e222d; color:#d1d4dc; font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto, sans-serif; margin:20px; }
  #chart { height:500px; border:1px solid #2a2e39; border-radius:6px; margin-bottom:12px; }
  .controls { margin-bottom:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  button { padding:8px 14px; background:#2962ff; color:white; border:none; border-radius:6px; cursor:pointer; }
  button:disabled { opacity:0.5; cursor:not-allowed; }
  .csv-display { background:#2a2e39; padding:10px; border-radius:6px; max-height:220px; overflow:auto; font-family:monospace; font-size:13px; white-space:pre; }
  .info { display:flex; gap:14px; margin-bottom:8px; flex-wrap:wrap; }
  .info div { background:#23272e; padding:8px 10px; border-radius:6px; }
</style>
</head>
<body>

<h2>OHLCV â€” LSTM Live Predictions</h2>

<div class="controls">
  <button id="startBtn">Load candles from server</button>
  <button id="nextBtn" disabled>Next Candle (Space)</button>
  <button id="exportBtn" disabled>Export CSV</button>
</div>

<div class="info">
  <div>Current Candle: <span id="currentCandle">-</span></div>
  <div>Close Price: <span id="closePrice">-</span></div>
  <div>Predicted: <span id="predictedLabel">-</span></div>
  <div>Logits: <span id="logitsBox">-</span></div>
</div>

<div id="chart"></div>

<h4>CSV log (last lines)</h4>
<div class="csv-display" id="csvLog"></div>

<script>
(async () => {
  const container = document.getElementById('chart');
  const chart = LightweightCharts.createChart(container, {
    layout: { background: { color: '#131722' }, textColor: '#d1d4dc' },
    grid: { vertLines: { color: '#2a2e39' }, horzLines: { color: '#2a2e39' } },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor: '#2a2e39' },
    timeScale: { borderColor: '#2a2e39', timeVisible: true, secondsVisible: false }
  });

  const candleSeries = chart.addCandlestickSeries({
    upColor: '#26a69a', downColor: '#ef5350', borderVisible:false,
    wickUpColor:'#26a69a', wickDownColor:'#ef5350'
  });

  const startBtn = document.getElementById('startBtn');
  const nextBtn  = document.getElementById('nextBtn');
  const exportBtn = document.getElementById('exportBtn');
  const currentCandleEl = document.getElementById('currentCandle');
  const closePriceEl = document.getElementById('closePrice');
  const predictedLabelEl = document.getElementById('predictedLabel');
  const logitsBoxEl = document.getElementById('logitsBox');
  const csvLogEl = document.getElementById('csvLog');

  let allRows = [];
  let currentIndex = 0;
  let logged = [];
  let predictedMarkers = [];
  let labelMapping = [];

  async function loadMeta() {
    const res = await fetch('/meta');
    const j = await res.json();
    labelMapping = j.label_classes;
  }

  async function loadCandles() {
    startBtn.disabled = true;
    startBtn.textContent = 'Loading...';
    try {
      await loadMeta();
      const res = await fetch('/candles');
      if (!res.ok) throw new Error('Failed to fetch /candles');
      const data = await res.json();
      allRows = data.map(r => ({
        time: r.time,
        open: +r.open,
        high: +r.high,
        low:  +r.low,
        close:+r.close
      }));

      if (allRows.length === 0) throw new Error('No candles returned');

      currentIndex = 0;
      candleSeries.setData([allRows[0]]);
      updateDisplay();
      predictedMarkers = [];
      candleSeries.setMarkers([]);
      nextBtn.disabled = false;
      exportBtn.disabled = false;
      startBtn.textContent = 'Loaded';
    } catch (err) {
      console.error(err);
      alert('Error loading candles: ' + err.message);
      startBtn.disabled = false;
      startBtn.textContent = 'Load candles from server';
    }
  }

  function updateDisplay() {
    if (!allRows.length) return;
    const c = allRows[currentIndex];
    currentCandleEl.textContent = unixToStr(c.time);
    closePriceEl.textContent = `$${c.close.toFixed(2)}`;
    // Removed resets for predictedLabelEl and logitsBoxEl
  }

  function unixToStr(t) {
    return new Date(t * 1000).toISOString().slice(0,19).replace('T',' ');
  }

  function addPredictionMarker(idx, label) {
    predictedMarkers.push({
      time: allRows[idx].time,
      position: 'aboveBar',
      color: '#ff6b35',
      shape: 'circle',
      text: String(label)
    });
    candleSeries.setMarkers(predictedMarkers);
  }

async function nextCandle() {
  if (currentIndex >= allRows.length - 1) {
    alert('Reached end of dataset');
    nextBtn.disabled = true;
    return;
  }

  // Move to the next candle first
  currentIndex++;
  candleSeries.update(allRows[currentIndex]);

  let predicted = '-';
  try {
    const res = await fetch('/predict', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ idx: currentIndex })
    });
    if (res.ok) {
      const j = await res.json();
      if (j && j.class !== undefined && j.logits) {
        predicted = labelMapping[j.class] || String(j.class);
        predictedLabelEl.textContent = predicted;
        logitsBoxEl.textContent = j.logits.map(v => v.toFixed(4)).join(', ');

        // Only add marker if class != 0
        if (j.class !== 0) {
          addPredictionMarker(currentIndex, predicted);
        }
      }
    }
  } catch (err) {
    console.warn('Prediction failed:', err);
  }

  const c = allRows[currentIndex];
  logged.push(`${unixToStr(c.time)},${c.close},${predicted}`);
  updateCSVLog();

  // Adjust view to keep new candle visible
  const vr = chart.timeScale().getVisibleRange();
  if (vr) {
    const rangeSize = vr.to - vr.from;
    let newFrom = vr.from + 1;
    let newTo = vr.to + 1;
    if (newTo > allRows[allRows.length - 1].time) {
      newTo = allRows[allRows.length - 1].time;
      newFrom = newTo - rangeSize;
    }
    chart.timeScale().setVisibleRange({ from: newFrom, to: newTo });
  }

  updateDisplay();
}

  function updateCSVLog() {
    const last = logged.slice(-15).join('\n');
    csvLogEl.textContent = last;
  }

  function exportCSV() {
    if (logged.length === 0) {
      alert('No predictions logged');
      return;
    }
    const header = 'timestamp,close,label\n';
    const blob = new Blob([header + logged.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'lstm_predictions.csv';
    a.click();
    URL.revokeObjectURL(url);
  }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && !e.repeat) {
      e.preventDefault();
      if (!nextBtn.disabled) nextCandle();
    }
  });

  startBtn.addEventListener('click', loadCandles);
  nextBtn.addEventListener('click', nextCandle);
  exportBtn.addEventListener('click', exportCSV);
})();
</script>
</body>
</html>

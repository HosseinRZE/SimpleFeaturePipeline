<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OHLC Labeling Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root { --bg:#ffffff; --fg:#111; --muted:#777; --accent:#e53935; --hline:#2979ff; }
    html, body { height: 100%; margin: 0; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      flex-direction: column;
    }
    #controls {
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid #e5e7eb;
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 5;
    }
    #wrapper {
      position: relative;
      width: 100%;
      flex: 1 1 auto;
    }
    #chart { width: 100%; height: 100%; }
    #overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 9999;
    }
    .vline {
      position: absolute;
      top: 0; bottom: 0;
      width: 2px;
      background: var(--accent);
      opacity: 0.95;
      transform: translateX(-50%);
      z-index: 10000;
    }
    .hint { font-size: 12px; color: var(--muted); margin-left: auto; }
    button { padding: 6px 12px; border:1px solid #e5e7eb; background:#f8fafc; border-radius:8px; cursor:pointer; }
    button:hover { background:#eef2ff; }
    input[type="file"] { font-size: 14px; }
    .badge { font-size: 12px; padding: 2px 6px; border-radius: 999px; border:1px solid #e5e7eb; }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="csvFile" accept=".csv" />
    <button id="saveLog">Save Log</button>
    <button id="undoBtn">Undo</button>
    <span class="badge" id="stageBadge">Stage: pick start</span>
    <span class="hint">Clicks: start → end. Press <b>a–l</b> then click for horizontals. Press <b>Space</b> to log & clear.</span>
  </div>

  <div id="wrapper">
    <div id="chart"></div>
    <div id="overlay"></div>
  </div>

  <script>
    const chartEl = document.getElementById('chart');
    const overlay = document.getElementById('overlay');
    const stageBadge = document.getElementById('stageBadge');

    // --- Chart setup ---
    const chart = LightweightCharts.createChart(chartEl, {
      layout: { background: { type: 'solid', color: '#fff' }, textColor: '#111' },
      grid: { vertLines: { visible: false }, horzLines: { visible: false } },
      crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
      rightPriceScale: { borderVisible: false },
      timeScale: { borderVisible: false },
    });
    const series = chart.addCandlestickSeries();

    // --- State ---
    let data = [];
    let indexByTime = new Map();
    let startTime = null;
    let endTime = null;
    let priceLines = [];
    let logs = [];
    const STAGES = { START: 0, END: 1, HLINES: 2 };
    let stage = STAGES.START;
    let lastAction = null;

    // new state for keyed horizontals
    let currentKey = null;
    let usedKeys = new Set();
    const KEY_MAP = {
      'a': 'linePrice_1',
      's': 'linePrice_2',
      'd': 'linePrice_3',
      'f': 'linePrice_4',
      'g': 'linePrice_5',
      'h': 'linePrice_6',
      'j': 'linePrice_7',
      'k': 'linePrice_8',
      'l': 'linePrice_9',
    };

    function setStage(s) {
      stage = s;
      stageBadge.textContent = 'Stage: ' + (s === STAGES.START ? 'pick start' : s === STAGES.END ? 'pick end' : 'add horizontals');
    }

    // --- CSV parsing ---
    function isDigits(s){ return s && Array.from(s).every(ch => ch >= '0' && ch <= '9'); }
    function toSec(t){ return isDigits(t) ? Math.floor(+t) : Math.floor(new Date(t).getTime() / 1000); }
    function parseCSV(text) {
      const rows = text.replace(/\r/g, '').trim().split('\n');
      return rows.slice(1).map(r => {
        const parts = r.split(',');
        const t = toSec((parts[0] || '').trim());
        return { time: t, open: +parts[1], high: +parts[2], low: +parts[3], close: +parts[4] };
      }).filter(d => Number.isFinite(d.time));
    }

    document.getElementById('csvFile').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        data = parseCSV(evt.target.result);
        series.setData(data);
        indexByTime = new Map(data.map((d,i)=>[d.time,i]));
        clearAll(false);
      };
      reader.readAsText(file);
    });

    // --- Vertical lines rendering fix ---
    function getCanvasLeftOffset() {
      const canvas = chartEl.querySelector('canvas');
      if (!canvas) return 0;
      const canvasRect = canvas.getBoundingClientRect();
      const overlayRect = overlay.getBoundingClientRect();
      return canvasRect.left - overlayRect.left;
    }

    function renderVerticals() {
      overlay.innerHTML = '';
      const offset = getCanvasLeftOffset();
      const drawLine = (time) => {
        if (time == null) return;
        const x = chart.timeScale().timeToCoordinate(time);
        if (x == null || isNaN(x)) return;
        const el = document.createElement('div');
        el.className = 'vline';
        el.style.left = Math.round(x + offset) + 'px';
        overlay.appendChild(el);
      };
      if (startTime != null) drawLine(startTime);
      if (endTime != null) drawLine(endTime);
    }

    chart.timeScale().subscribeVisibleTimeRangeChange(renderVerticals);
    new ResizeObserver(renderVerticals).observe(chartEl);

    // --- Horizontal lines (keyed) ---
    function addHorizontal(price, key) {
      const pl = series.createPriceLine({
        price,
        color: 'rgba(41,121,255,0.9)',
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Solid,
        axisLabelVisible: true,
        title: key.toUpperCase()
      });
      priceLines.push({ obj: pl, price, key });
      usedKeys.add(key);
      currentKey = null;
    }

// --- Clear / log ---
function clearAll(logIt = true) {
  if (logIt && startTime != null && endTime != null) {
    let si = indexByTime.get(startTime);
    let ei = indexByTime.get(endTime);

    // Ensure startTime < endTime
    if (si > ei) {
      [si, ei] = [ei, si];
      [startTime, endTime] = [endTime, startTime];
    }

    if (si != null && ei != null) {
      const closeAtEnd = data[ei].close;
      const lineObj = {};
      priceLines.forEach(p => {
        lineObj[KEY_MAP[p.key]] = (p.price / closeAtEnd).toFixed(6);
      });

      logs.push({
        startIndex: si,
        endIndex: ei,
        startTime,
        endTime,
        ...lineObj
      });
    }
  }

  // Clear horizontal lines
  priceLines.forEach(p => series.removePriceLine(p.obj));
  priceLines = [];
  startTime = null;
  endTime = null;
  usedKeys.clear();
  currentKey = null;
  renderVerticals();
  setStage(STAGES.START);
}


    // --- Interactions ---
    chart.subscribeClick(param => {
      if (!param || param.time == null || !param.point) return;
      const t = param.time;
      const price = series.coordinateToPrice(param.point.y);
      if (price == null) return;

      if (stage === STAGES.START) {
        startTime = t; renderVerticals(); setStage(STAGES.END); lastAction='start';
      } else if (stage === STAGES.END) {
        endTime = t; renderVerticals(); setStage(STAGES.HLINES); lastAction='end';
      } else if (stage === STAGES.HLINES) {
        if (currentKey && KEY_MAP[currentKey] && !usedKeys.has(currentKey)) {
          addHorizontal(price, currentKey);
          lastAction='hline';
        }
      }
    });

    // Undo button
    document.getElementById('undoBtn').addEventListener('click', () => {
      if (lastAction==='hline' && priceLines.length>0) {
        const p = priceLines.pop();
        series.removePriceLine(p.obj);
        usedKeys.delete(p.key);
      } else if (lastAction==='end' && endTime!=null) {
        endTime=null; renderVerticals(); setStage(STAGES.END);
      } else if (lastAction==='start' && startTime!=null) {
        startTime=null; renderVerticals(); setStage(STAGES.START);
      }
      lastAction=null;
    });

    function isTypingInInput(e){ 
      const el=e.target;
      if(!el)return false;
      const t=(el.tagName||'').toLowerCase();
      return t==='input'||t==='textarea'||el.isContentEditable; 
    }

    window.addEventListener('keydown', e => {
      if (isTypingInInput(e)) return;

      if (e.code === 'Space') {
        e.preventDefault();
        clearAll(true);
      } else {
        const k = e.key.toLowerCase();
        if (KEY_MAP[k] && !usedKeys.has(k)) {
          currentKey = k;
        }
      }
    });

    // --- Save log ---
    document.getElementById('saveLog').addEventListener('click', () => {
      if (logs.length === 0) return alert('No logs to save');

      const headers = ['startTime','endTime','startIndex','endIndex', ...Object.values(KEY_MAP)];
      const csv = [headers.join(',')];

      logs.forEach(l => {
        const row = headers.map(h => l[h] ?? '');
        csv.push(row.join(','));
      });

      const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ohlcv_labels.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
